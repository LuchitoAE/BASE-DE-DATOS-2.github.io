<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Semana 9 - Optimizaci√≥n y Rendimiento</title>
    <link rel="stylesheet" href="../assets/css/global.css"> <!-- Global Design System -->
    <link rel="stylesheet" href="../assets/css/sections/semanas.css"> <!-- Week-specific styles -->
</head>

<body>
    <div class="page-container">
        <header>
            <div class="container">
                <div class="left">
                    <a href="../index.html">INICIO</a>
                </div>
                <div class="right">
                    <a href="../examenfinal.html">Examen Final</a>
                    <a href="../libro/modulo1.html">Libro SQL server</a>
                    <a href="../misdatos.html">Mis datos</a>
                    <a href="../curso.html">Curso</a>
                    <div class="dropdown">
                        <button class="dropbtn">Semanas</button>
                        <div class="dropdown-content">
                            <a href="../semanas/semana1.html">Semana 1</a>
                            <a href="../semanas/semana2.html">Semana 2</a>
                            <a href="../semanas/semana3.html">Semana 3</a>
                            <a href="../semanas/semana4.html">Semana 4</a>
                            <a href="../semanas/semana5.html">Semana 5</a>
                            <a href="../semanas/semana6.html">Semana 6</a>
                            <a href="../semanas/semana7.html">Semana 7</a>
                            <a href="../semanas/semana8.html">Semana 8</a>
                            <a href="../semanas/semana9.html">Semana 9</a>
                            <a href="../semanas/semana10.html">Semana 10</a>
                            <a href="../semanas/semana11.html">Semana 11</a>
                            <a href="../semanas/semana12.html">Semana 12</a>
                        </div>
                    </div>
                </div>
            </div>
        </header>

        <main>
            <div class="content-section">
                <div class="text-block">
                    <h1>Semana 9: Optimizaci√≥n y Rendimiento en SQL Server</h1>
                    <h2>üöÄ Introducci√≥n a la Optimizaci√≥n</h2>
                    <p>
                        La optimizaci√≥n de consultas es fundamental para garantizar que una base de datos funcione de
                        manera eficiente.
                        Una consulta mal optimizada puede ralentizar dr√°sticamente una aplicaci√≥n, especialmente cuando
                        los datos crecen.
                    </p>
                    <p>
                        En esta semana aprenderemos t√©cnicas y herramientas para:
                    </p>
                    <ul>
                        <li>Identificar cuellos de botella en el rendimiento</li>
                        <li>Optimizar consultas SQL</li>
                        <li>Utilizar √≠ndices de manera efectiva</li>
                        <li>Interpretar planes de ejecuci√≥n</li>
                        <li>Monitorear y analizar el rendimiento</li>
                    </ul>
                </div>
            </div>

            <div class="content-section">
                <div class="text-block">
                    <h2>üìä √çndices: La Clave del Rendimiento</h2>

                    <h3>¬øQu√© son los √çndices?</h3>
                    <p>
                        Los √≠ndices son estructuras de datos que mejoran la velocidad de recuperaci√≥n de datos de una
                        tabla.
                        Funcionan de manera similar al √≠ndice de un libro: en lugar de leer todo el libro para encontrar
                        un tema,
                        consultas el √≠ndice para saltar directamente a la p√°gina correcta.
                    </p>

                    <h3>Tipos de √çndices</h3>
                    <ul>
                        <li><strong>Clustered Index:</strong> Ordena f√≠sicamente los datos en la tabla (solo uno por
                            tabla)</li>
                        <li><strong>Non-Clustered Index:</strong> Crea una estructura separada con punteros a los datos
                        </li>
                        <li><strong>Unique Index:</strong> Garantiza que no haya valores duplicados</li>
                        <li><strong>Filtered Index:</strong> √çndice sobre un subconjunto de filas</li>
                        <li><strong>Columnstore Index:</strong> Optimizado para consultas anal√≠ticas</li>
                    </ul>

                    <h3>Crear √çndices</h3>
                    <pre>-- √çndice no agrupado simple
CREATE INDEX IX_Products_CategoryID 
ON products(category_id);

-- √çndice compuesto (m√∫ltiples columnas)
CREATE INDEX IX_Orders_CustomerDate 
ON orders(customer_id, order_date);

-- √çndice √∫nico
CREATE UNIQUE INDEX IX_Customers_Email 
ON customers(email);

-- √çndice filtrado (solo productos activos)
CREATE INDEX IX_Products_Active 
ON products(product_name, list_price)
WHERE is_active = 1;

-- √çndice con columnas incluidas
CREATE INDEX IX_Products_CategoryBrand 
ON products(category_id, brand_id)
INCLUDE (product_name, list_price);</pre>
                </div>
            </div>

            <div class="content-section">
                <div class="text-block">
                    <h2>üìà Planes de Ejecuci√≥n</h2>
                    <p>
                        Los planes de ejecuci√≥n muestran c√≥mo SQL Server ejecuta una consulta. Son esenciales para
                        identificar problemas de rendimiento.
                    </p>

                    <h3>Obtener un Plan de Ejecuci√≥n</h3>
                    <pre>-- Activar plan de ejecuci√≥n estimado
SET SHOWPLAN_ALL ON;
GO

-- Tu consulta aqu√≠
SELECT p.product_name, c.category_name
FROM products p
INNER JOIN categories c ON p.category_id = c.category_id;

SET SHOWPLAN_ALL OFF;
GO

-- O usar este m√©todo m√°s com√∫n
SET STATISTICS IO ON;
SET STATISTICS TIME ON;

SELECT * FROM products WHERE category_id = 5;

SET STATISTICS IO OFF;
SET STATISTICS TIME OFF;</pre>

                    <h3>Elementos Clave en el Plan</h3>
                    <ul>
                        <li><strong>Table Scan:</strong> Lee toda la tabla (‚ùå generalmente malo)</li>
                        <li><strong>Index Scan:</strong> Lee todo el √≠ndice (‚ö†Ô∏è puede ser costoso)</li>
                        <li><strong>Index Seek:</strong> Busca espec√≠ficamente en el √≠ndice (‚úÖ excelente)</li>
                        <li><strong>Key Lookup:</strong> B√∫squeda adicional para obtener columnas no indexadas (‚ö†Ô∏è puede
                            ser costoso)</li>
                        <li><strong>Nested Loops:</strong> M√©todo de uni√≥n para conjuntos peque√±os</li>
                        <li><strong>Hash Match:</strong> M√©todo de uni√≥n para conjuntos grandes</li>
                        <li><strong>Merge Join:</strong> Eficiente cuando ambas tablas est√°n ordenadas</li>
                    </ul>
                </div>
            </div>

            <div class="content-section">
                <div class="text-block">
                    <h2>‚ö° Optimizaci√≥n de Consultas</h2>

                    <h3>1. Evitar SELECT *</h3>
                    <pre>-- ‚ùå MAL - Trae todas las columnas
SELECT * FROM products;

-- ‚úÖ BIEN - Solo las columnas necesarias
SELECT product_id, product_name, list_price 
FROM products;</pre>

                    <h3>2. Usar WHERE en lugar de HAVING cuando sea posible</h3>
                    <pre>-- ‚ùå MAL - HAVING filtra despu√©s de agrupar
SELECT category_id, COUNT(*) 
FROM products
GROUP BY category_id
HAVING category_id = 1;

-- ‚úÖ BIEN - WHERE filtra antes de agrupar
SELECT category_id, COUNT(*) 
FROM products
WHERE category_id = 1
GROUP BY category_id;</pre>

                    <h3>3. Evitar Funciones en WHERE sobre columnas indexadas</h3>
                    <pre>-- ‚ùå MAL - No puede usar el √≠ndice
SELECT * FROM orders
WHERE YEAR(order_date) = 2026;

-- ‚úÖ BIEN - Puede usar √≠ndice en order_date
SELECT * FROM orders
WHERE order_date >= '2026-01-01' 
  AND order_date < '2027-01-01';</pre>

                    <h3>4. Usar EXISTS en lugar de IN con subconsultas</h3>
                    <pre>-- ‚ùå MENOS EFICIENTE
SELECT * FROM customers
WHERE customer_id IN (
    SELECT customer_id FROM orders
    WHERE order_date > '2026-01-01'
);

-- ‚úÖ M√ÅS EFICIENTE
SELECT * FROM customers c
WHERE EXISTS (
    SELECT 1 FROM orders o
    WHERE o.customer_id = c.customer_id
      AND o.order_date > '2026-01-01'
);</pre>

                    <h3>5. Evitar OR, usar UNION cuando sea apropiado</h3>
                    <pre>-- ‚ùå MAL - OR puede impedir uso de √≠ndices
SELECT * FROM products
WHERE category_id = 1 OR brand_id = 5;

-- ‚úÖ MEJOR - Si es apropiado para tu caso
SELECT * FROM products WHERE category_id = 1
UNION
SELECT * FROM products WHERE brand_id = 5;</pre>
                </div>
            </div>

            <div class="content-section">
                <div class="text-block">
                    <h2>üìä Estad√≠sticas de SQL Server</h2>
                    <p>
                        SQL Server utiliza estad√≠sticas para crear planes de ejecuci√≥n √≥ptimos.
                        Las estad√≠sticas desactualizadas pueden causar planes de ejecuci√≥n ineficientes.
                    </p>

                    <h3>Actualizar Estad√≠sticas</h3>
                    <pre>-- Actualizar estad√≠sticas de una tabla
UPDATE STATISTICS products;

-- Actualizar estad√≠sticas de un √≠ndice espec√≠fico
UPDATE STATISTICS products IX_Products_CategoryID;

-- Actualizar todas las estad√≠sticas de la base de datos
EXEC sp_updatestats;

-- Ver estad√≠sticas de una tabla
DBCC SHOW_STATISTICS('products', 'IX_Products_CategoryID');</pre>

                    <h3>Reconstruir √çndices</h3>
                    <pre>-- Reconstruir un √≠ndice espec√≠fico
ALTER INDEX IX_Products_CategoryID ON products REBUILD;

-- Reconstruir todos los √≠ndices de una tabla
ALTER INDEX ALL ON products REBUILD;

-- Reorganizar (menos intensivo que rebuild)
ALTER INDEX IX_Products_CategoryID ON products REORGANIZE;</pre>
                </div>
            </div>

            <div class="content-section">
                <div class="text-block">
                    <h2>üîç Herramientas de Monitoreo</h2>

                    <h3>1. DMVs (Dynamic Management Views)</h3>
                    <p>Vistas del sistema que proporcionan informaci√≥n sobre el rendimiento:</p>
                    <pre>-- Consultas m√°s costosas
SELECT TOP 10
    qs.execution_count,
    qs.total_elapsed_time / 1000000 AS total_elapsed_time_seconds,
    qs.total_worker_time / 1000000 AS total_cpu_time_seconds,
    SUBSTRING(qt.text, (qs.statement_start_offset/2)+1, 
        ((CASE qs.statement_end_offset
            WHEN -1 THEN DATALENGTH(qt.text)
            ELSE qs.statement_end_offset
        END - qs.statement_start_offset)/2) + 1) AS query_text
FROM sys.dm_exec_query_stats qs
CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) qt
ORDER BY qs.total_elapsed_time DESC;

-- √çndices faltantes sugeridos
SELECT 
    migs.avg_user_impact,
    migs.user_seeks,
    mid.statement,
    mid.equality_columns,
    mid.inequality_columns,
    mid.included_columns
FROM sys.dm_db_missing_index_group_stats migs
JOIN sys.dm_db_missing_index_groups mig 
    ON migs.group_handle = mig.index_group_handle
JOIN sys.dm_db_missing_index_details mid 
    ON mig.index_handle = mid.index_handle
ORDER BY migs.avg_user_impact DESC;</pre>

                    <h3>2. Query Store</h3>
                    <p>Funcionalidad que registra el historial de consultas y planes de ejecuci√≥n:</p>
                    <pre>-- Habilitar Query Store
ALTER DATABASE BikeStores 
SET QUERY_STORE = ON;

-- Configurar Query Store
ALTER DATABASE BikeStores 
SET QUERY_STORE (
    OPERATION_MODE = READ_WRITE,
    DATA_FLUSH_INTERVAL_SECONDS = 900,
    MAX_STORAGE_SIZE_MB = 1000
);</pre>
                </div>
            </div>

            <div class="content-section">
                <div class="text-block">
                    <h2>üí° Best Practices de Rendimiento</h2>

                    <h3>Dise√±o de Base de Datos</h3>
                    <ul>
                        <li>‚úîÔ∏è Normalizar apropiadamente (3NF generalmente)</li>
                        <li>‚úîÔ∏è Considerar desnormalizaci√≥n estrat√©gica para reporting</li>
                        <li>‚úîÔ∏è Usar tipos de datos apropiados (m√°s peque√±os cuando sea posible)</li>
                        <li>‚úîÔ∏è Implementar particionamiento para tablas muy grandes</li>
                    </ul>

                    <h3>√çndices</h3>
                    <ul>
                        <li>‚úîÔ∏è Crear √≠ndices en columnas frecuentemente usadas en WHERE, JOIN, ORDER BY</li>
                        <li>‚úîÔ∏è No sobre-indexar (cada √≠ndice tiene costo en INSERT/UPDATE/DELETE)</li>
                        <li>‚úîÔ∏è Considerar √≠ndices compuestos para consultas comunes</li>
                        <li>‚úîÔ∏è Mantener estad√≠sticas actualizadas</li>
                        <li>‚úîÔ∏è Monitorear fragmentaci√≥n de √≠ndices</li>
                    </ul>

                    <h3>Consultas</h3>
                    <ul>
                        <li>‚úîÔ∏è Limitar resultados con TOP o paginaci√≥n</li>
                        <li>‚úîÔ∏è Evitar cursores cuando sea posible (usar operaciones set-based)</li>
                        <li>‚úîÔ∏è Usar procedimientos almacenados para consultas frecuentes</li>
                        <li>‚úîÔ∏è Implementar cach√© en la capa de aplicaci√≥n</li>
                        <li>‚úîÔ∏è Usar transacciones apropiadamente</li>
                    </ul>
                </div>
            </div>

            <div class="content-section">
                <div class="text-block">
                    <h2>üìù Ejercicios Pr√°cticos</h2>

                    <h3>Ejercicio 1: An√°lisis de Plan de Ejecuci√≥n</h3>
                    <p>
                        Ejecuta la siguiente consulta y analiza su plan de ejecuci√≥n. Identifica oportunidades de
                        optimizaci√≥n:
                    </p>
                    <pre>SELECT c.first_name, c.last_name, COUNT(o.order_id) as total_orders
FROM customers c
LEFT JOIN orders o ON c.customer_id = o.customer_id
WHERE c.city = 'New York'
GROUP BY c.first_name, c.last_name
ORDER BY total_orders DESC;</pre>

                    <h3>Ejercicio 2: Crear √çndices √ìptimos</h3>
                    <p>
                        Para la siguiente consulta frecuente en tu sistema, dise√±a √≠ndices √≥ptimos:
                    </p>
                    <pre>SELECT p.product_name, p.list_price, b.brand_name, c.category_name
FROM products p
INNER JOIN brands b ON p.brand_id = b.brand_id
INNER JOIN categories c ON p.category_id = c.category_id
WHERE p.list_price > 1000
  AND c.category_name = 'Mountain Bikes'
ORDER BY p.list_price DESC;</pre>

                    <h3>Ejercicio 3: Optimizaci√≥n de Consulta</h3>
                    <p>
                        Optimiza esta consulta que est√° causando problemas de rendimiento:
                    </p>
                    <pre>SELECT * FROM orders
WHERE MONTH(order_date) = 3
  AND YEAR(order_date) = 2026
  AND customer_id IN (
      SELECT customer_id FROM customers WHERE city LIKE '%New%'
  )
ORDER BY order_date DESC;</pre>
                </div>
            </div>

        </main>

        <footer>
            <div class="footer-container">
                <p>&copy; 2026 Luis Walter Aquino Espinoza. Todos los derechos reservados.</p>
                <p>Pol√≠tica de Privacidad | T√©rminos de Servicio</p>
            </div>
        </footer>
    </div>
    <script src="../assets/js/theme.js"></script>
</body>

</html>
